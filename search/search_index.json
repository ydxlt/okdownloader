{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OkDownloader","text":"<p>A downloader base on OkHttp for Java and Android.</p> <ul> <li>Easy to use: API like OkHttp</li> <li>Many features: support many scenes, such as synchronous/asynchronous download, you can use it easy in coroutines</li> <li>Modern: OkDownloader is Kotlin-first and base on OkHttp</li> <li>Easy to expand: support SPI and dynomic Interceptor to expand</li> </ul>"},{"location":"#download","title":"Download","text":"<p>OkDownloader is available on <code>mavenCentral()</code>.</p> <pre><code>implementation(\"com.billbook.lib:downloader:1.0.0\")\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Build a downloader just like build OkHttpClient</p> <pre><code>val downloader = Downloader.Builder().build()\n</code></pre> <p>Start download</p> <pre><code>val request = Download.Request.Builder()\n.url(url)\n.into(path) // or into(file)\n.build()\nval call = downloader.newCall(request)\nval response = call.execute() // synchronous download\n// use response here\n</code></pre> <p>or</p> <pre><code>call.enqueue() // Asynchronous download\n</code></pre> <p>with callback</p> <pre><code>call.enqueue(object : Download.Callback {\n// ...\noverride fun onSuccess(call: Download.Call, response: Download.Response) {\n// do your job\n}\noverride fun onFailure(call: Download.Call, response: Download.Response) {\n// do your job\n}\n})\n</code></pre> <p>Cancel download</p> <pre><code>call.cancel() // or call.cancelSafely()\n</code></pre>"},{"location":"#how-to-expand","title":"How to expand","text":"<p>Dynamically add interceptors</p> <pre><code>val downloader = Downloader.Builder()\n.addInterceptor(CustomInterceptor())\n.build()\n</code></pre> <p>or</p> <p>Declare your interceptors using SPI,In META-INF/services/com.billbook.lib.Interceptor</p> <pre><code>com.example.CustomInterceptor1\ncom.example.CustomInterceptor2\ncom.example.CustomInterceptor3\n</code></pre>"},{"location":"#r8proguard","title":"R8/Proguard","text":"<p>OkDownloader is fully compatible with R8 out of the box and doesn't require adding any extra rules. If you use Proguard, you may need to add rules for OkHttp and Okio.</p>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2023 Billbook, Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"change_logs/","title":"Change Logs","text":""},{"location":"change_logs/#change-log","title":"Change Log","text":""},{"location":"contributing/","title":"Contributing","text":"<p>Keeping the project small and stable limits our ability to accept new contributors. We are not seeking new committers at this time, but some small contributions are welcome.</p> <p>If you\u2019ve found a security problem, please follow our bug bounty program.</p> <p>If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it.</p> <p>If you have a new feature idea, please build it in an external library. There are many libraries that sit on top or hook in via existing APIs. If you build something that integrates with OkDownloader, tell us so that we can link it!</p> <p>Modified from OkHttp's Contributing section.</p>"},{"location":"downloader_pipeline/","title":"How to Expand","text":"<p>Dynamically add interceptors</p> <pre><code>val downloader = Downloader.Builder()\n.addInterceptor(CustomInterceptor())\n.build()\n</code></pre> <p>or</p> <p>Declare your interceptors using SPI,In META-INF/services/com.billbook.lib.Interceptor</p> <pre><code>com.example.CustomInterceptor1\ncom.example.CustomInterceptor2\ncom.example.CustomInterceptor3\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#asynchronous-download","title":"Asynchronous Download","text":"<p><code>Asynchronous download</code> means executing in an asynchronous thread.</p> <pre><code>val request = Download.Request.Builder()\n.url(url)\n.into(file)\n.build()\nval call = downloader.newCall(request)\ncall.enqueue()\n</code></pre> <p>Add callback listeners:</p> <pre><code>call.enqueue(object : Download.Callback {\n// ...\noverride fun onSuccess(call: Download.Call, response: Download.Response) {\n// do your job\n}\noverride fun onFailure(call: Download.Call, response: Download.Response) {\n// do your job\n}\n})\n</code></pre>"},{"location":"getting_started/#synchronous-download","title":"Synchronous Download","text":"<p><code>Synchronous download</code> means executing in the current thread, blocking the calling thread.</p> <pre><code>val request = Download.Request.Builder()\n.url(url)\n.into(file)\n.build()\nval call = downloader.newCall(request)\nval response = call.execute()\n</code></pre> <p>Add callback listeners</p> <pre><code>call.execute(object : Download.Callback {\n// ...\noverride fun onSuccess(call: Download.Call, response: Download.Response) {\n// do your job\n}\noverride fun onFailure(call: Download.Call, response: Download.Response) {\n// do your job\n}\n})\n</code></pre> <p>Usually, synchronous download is used in coroutines:</p> <pre><code>withContext(Dispatchers.IO) {\nval request = Download.Request.Builder()\n.url(url)\n.into(file)\n.build()\nval response = downloader.newCall(request).execute()\n}\n</code></pre>"},{"location":"getting_started/#canceling-download","title":"Canceling Download","text":"<pre><code>call.cancel()\n</code></pre> <p>or</p> <pre><code>call.cancelSafely()\n</code></pre> <p>The difference between <code>cancel</code> and <code>cancelSafely</code> is that <code>cancelSafely()</code> will delete the downloaded temporary file.</p>"},{"location":"getting_started/#file-verification","title":"File Verification","text":"<p>Set the <code>MD5</code> value to perform MD5 verification upon download completion</p> <pre><code>val request = Download.Request.Builder()\n// ..\n.md5(md5)\n.build()\n</code></pre> <p>Set the <code>size</code> of the file to verify the file size upon download completion:</p> <pre><code>val request = Download.Request.Builder()\n// ..\n.size(size)\n.build()\n</code></pre>"},{"location":"getting_started/#setting-retries","title":"Setting Retries","text":"<p>Set the number of retries. The default number of retries is 3:</p> <pre><code>val request = Download.Request.Builder()\n// ..\n.retry(5)\n.build()\n</code></pre>"},{"location":"getting_started/#setting-priority","title":"Setting Priority","text":"<p>Supports three priority levels: High, Middle, and Low. The default priority is Middle</p> <pre><code>val request = Download.Request.Builder()\n// ..\n.priority(Download.Priority.HIGH)\n.build()\n</code></pre>"},{"location":"getting_started/#setting-tags","title":"Setting Tags","text":"<p>Tags are used to label tasks and can be used to differentiate different tasks within the app for reporting purposes:</p> <pre><code>val request = Download.Request.Builder()\n// ..\n.tag(tag)\n.build()\n</code></pre>"},{"location":"getting_started/#task-subscription","title":"Task Subscription","text":"<p>In addition to task callbacks, task subscription is supported:</p> <pre><code>val subscriber = object : Download.Subscriber {\noverride fun onSuccess(call: Download.Call, response: Download.Response) {\n// Do your job\n}\noverride fun onFailure(call: Download.Call, response: Download.Response) {\n// Do your job\n}\n}\ndownloader.subscribe(subscriber)\n</code></pre> <p>Unsubscribe:</p> <pre><code>downloader.unsubscribe(subscriber)\n</code></pre>"},{"location":"optional_settings/","title":"Optional Settings","text":"<p>The following settings are optional and can be customized according to your project needs.</p>"},{"location":"optional_settings/#event-listeners","title":"Event Listeners","text":"<p>Set download event listeners using the <code>eventListenerFactory</code> method. For example:</p> <pre><code>val downloader = Downloader.Builder()\n.eventListenerFactory { ReporterEventListener() }\n.build()\n</code></pre> <p>ReporterEventListener:</p> <pre><code>class ReporterEventListener : EventListener() {\noverride fun callSuccess(call: Download.Call, response: Download.Response) {\n// do your job\n}\noverride fun callFailed(call: Download.Call, response: Download.Response) {\n// do your job\n}\n}\n</code></pre>"},{"location":"optional_settings/#idle-task-callback","title":"Idle Task Callback","text":"<p>Set idle task callback using the <code>idleCallback</code> method</p> <pre><code>val downloader = Downloader.Builder()\n.idleCallback { // handle download pool idle }\n.build()\n</code></pre>"},{"location":"optional_settings/#custom-okhttpclient","title":"Custom OkHttpClient","text":"<p>Set a custom OkHttpClient using the <code>okHttpClientFactory</code> method</p> <pre><code>val downloader = Downloader.Builder()\n.okHttpClientFactory { buildOkHttpClient() }\n.build()\nprivate fun buildOkHttpClient(): OkHttpClient {\nreturn OkHttpClient.Builder()\n.connectTimeout(15, TimeUnit.SECONDS)\n.readTimeout(15, TimeUnit.SECONDS)\n.writeTimeout(15, TimeUnit.SECONDS)\n.retryOnConnectionFailure(true)\n.cache(null)\n.build()\n}\n</code></pre>"},{"location":"optional_settings/#set-default-retry-count","title":"Set Default Retry Count","text":"<p>Set the default retry count. The default is 3</p> <pre><code>val downloader = Downloader.Builder()\n.defaultMaxRetry(10)\n.build()\n</code></pre>"},{"location":"optional_settings/#set-task-execution-thread-pool","title":"Set Task Execution Thread Pool","text":"<p>Set a custom asynchronous download task execution thread pool using the <code>executorService</code> method</p> <pre><code>val downloader = Downloader.Builder()\n.executorService(CustomExecutorService())\n.build()\n</code></pre>"}]}