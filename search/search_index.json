{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OkDownloader","text":"<p>A downloader library for Java and Android based on OkHttp.</p> <ul> <li>Easy to use: Simple API similar to OkHttp.</li> <li>Rich in features: Supports synchronous/asynchronous downloads, network restrictions, multithreading, task priorities, resource verification, and more.</li> <li>Modern: Written in Kotlin and based on OkHttp.</li> <li>Easy to extend: Supports adding interceptors through code and provides extension through the <code>SPI</code> mechanism.</li> </ul>"},{"location":"#download","title":"Download","text":"<p>OkDownloader is available on <code>mavenCentral()</code>.</p> <pre><code>implementation(\"com.billbook.lib:downloader:1.0.0\")\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Build a downloader instance just like building an OkHttpClient.</p> <pre><code>val downloader = Downloader.Builder().build()\n</code></pre> <p>Start download</p> <pre><code>val request = Download.Request.Builder()\n.url(url)\n.into(path) // or into(file)\n.build()\nval call = downloader.newCall(request)\nval response = call.execute() // synchronous download\n// use response here\n</code></pre> <p>or</p> <pre><code>call.enqueue() // Asynchronous download\n</code></pre> <p>Add callback listeners</p> <pre><code>call.enqueue(object : Download.Callback {\n// ...\noverride fun onSuccess(call: Download.Call, response: Download.Response) {\n// do your job\n}\noverride fun onFailure(call: Download.Call, response: Download.Response) {\n// do your job\n}\n})\n</code></pre> <p>Cancel download</p> <pre><code>call.cancel() // or call.cancelSafely()\n</code></pre>"},{"location":"#how-to-expand","title":"How to Expand","text":"<p>Add interceptors through code</p> <pre><code>val downloader = Downloader.Builder()\n.addInterceptor(CustomInterceptor())\n.build()\n</code></pre> <p>or</p> <p>Declare your interceptors in <code>META-INF/services/com.billbook.lib.Interceptor</code> using the <code>SPI</code> mechanism.</p> <pre><code>com.example.CustomInterceptor1\ncom.example.CustomInterceptor2\ncom.example.CustomInterceptor3\n</code></pre>"},{"location":"#r8proguard","title":"R8/Proguard","text":"<p>OkDownloader is fully compatible with R8 out of the box and doesn't require adding any extra rules. If you use Proguard, you may need to add rules for OkHttp and Okio.</p>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2023 Billbook, Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"best_practices/","title":"Best Practices","text":""},{"location":"best_practices/#managing-downloader-objects","title":"Managing Downloader Objects","text":"<p>Build and maintain a singleton downloader object to facilitate centralized management of download tasks. Different instances of the downloader have different download pools.</p> <p>In Android \ud83e\udef4Hilt</p> <pre><code>@Module\n@InstallIn(SingletonComponent::class)\nclass AppModule {\n@Singleton\n@Provides\nfun provideDownloader(@ApplicationContext context: Context): Downloader {\nreturn Downloader.Builder()\n.addInterceptor(CopyOnExistsInterceptor(context, 1000))\n.addInterceptor(NetworkInterceptor(context))\n.build()\n}\n}\n</code></pre> <p>If you want to manage tasks for different business purposes within your app, you can initialize a downloader and create new downloaders using the <code>newBuilder</code> method of the downloader. This allows the new downloaders to have different download pools while reusing thread pools and other resources.</p> <pre><code>val downloader = Downloader.Builder().build()\n</code></pre> <p>Business 1</p> <pre><code>val downloaderForBiz1 = downloader.newBuilder().build()\n</code></pre> <p>Business 2</p> <pre><code>val downloaderForBiz2 = downloader.newBuilder().build()\n</code></pre>"},{"location":"best_practices/#using-in-coroutines","title":"Using in Coroutines","text":"<p>Executing the call in the IO dispatcher</p> <pre><code>withContext(Dispatchers.IO) {\nval request = Download.Request.Builder()\n.url(url)\n.into(file)\n.build()\nval response = downloader.newCall(request).execute()\n}\n</code></pre> <p>By using coroutines with the IO dispatcher, you can perform the download operation asynchronously without blocking the main thread.</p>"},{"location":"change_logs/","title":"Change Logs","text":""},{"location":"change_logs/#change-log","title":"Change Log","text":""},{"location":"contributing/","title":"Contributing","text":"<p>Keeping the project small and stable limits our ability to accept new contributors. We are not seeking new committers at this time, but some small contributions are welcome.</p> <p>If you\u2019ve found a security problem, please follow our bug bounty program.</p> <p>If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it.</p> <p>If you have a new feature idea, please build it in an external library. There are many libraries that sit on top or hook in via existing APIs. If you build something that integrates with OkDownloader, tell us so that we can link it!</p> <p>Modified from OkHttp's Contributing section.</p>"},{"location":"downloader_pipeline/","title":"How to Expand","text":"<p>Add interceptors through code</p> <pre><code>val downloader = Downloader.Builder()\n.addInterceptor(CustomInterceptor())\n.build()\n</code></pre> <p>or</p> <p>Declare your interceptors in <code>META-INF/services/com.billbook.lib.Interceptor</code> using the <code>SPI</code> mechanism.</p> <pre><code>com.example.CustomInterceptor1\ncom.example.CustomInterceptor2\ncom.example.CustomInterceptor3\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#how-to-pause-a-download","title":"How to pause a download","text":"<p>In OkDownloader, there is no specific <code>pause</code> method. Instead, you can use the <code>cancel</code> method, which cancels the download without deleting the already downloaded files, effectively pausing the download.</p> <pre><code>call.cancel()\n</code></pre> <p>The <code>cancelSafely()</code> method will deletes the downloaded temporary files.</p>"},{"location":"faq/#how-to-resume-a-download","title":"How to resume a download","text":"<p>In OkDownloader, there is no dedicated <code>resume</code> method. Download tasks in OkDownloader are treated as one-time operations. If a task is canceled and you want to resume it, you need to create a new <code>call</code> object and execute it again.</p> <pre><code>downloader.newCall(request).execute() // or enqueue()\n</code></pre> <p>Please note that this approach creates a new download task starting from the beginning. If you want to implement resumable downloads with support for partial downloads, you would need to handle the logic yourself, such as saving the progress and resuming from where it left off.</p> <p>Please refer to the specific documentation of the downloader library you are using for more detailed information on pausing and resuming download tasks.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#asynchronous-download","title":"Asynchronous Download","text":"<p><code>Asynchronous download</code> means executing in an asynchronous thread.</p> <pre><code>val request = Download.Request.Builder()\n.url(url)\n.into(file)\n.build()\nval call = downloader.newCall(request)\ncall.enqueue()\n</code></pre> <p>Add callback listeners</p> <pre><code>call.enqueue(object : Download.Callback {\n// ...\noverride fun onSuccess(call: Download.Call, response: Download.Response) {\n// do your job\n}\noverride fun onFailure(call: Download.Call, response: Download.Response) {\n// do your job\n}\n})\n</code></pre>"},{"location":"getting_started/#synchronous-download","title":"Synchronous Download","text":"<p><code>Synchronous download</code> means executing in the current thread, blocking the calling thread.</p> <pre><code>val request = Download.Request.Builder()\n.url(url)\n.into(file)\n.build()\nval call = downloader.newCall(request)\nval response = call.execute()\n</code></pre> <p>Add callback listeners</p> <pre><code>call.execute(object : Download.Callback {\n// ...\noverride fun onSuccess(call: Download.Call, response: Download.Response) {\n// do your job\n}\noverride fun onFailure(call: Download.Call, response: Download.Response) {\n// do your job\n}\n})\n</code></pre> <p>Usually, synchronous download is used in coroutines:</p> <pre><code>withContext(Dispatchers.IO) {\nval request = Download.Request.Builder()\n.url(url)\n.into(file)\n.build()\nval response = downloader.newCall(request).execute()\n}\n</code></pre>"},{"location":"getting_started/#canceling-download","title":"Canceling Download","text":"<pre><code>call.cancel()\n</code></pre> <p>or</p> <pre><code>call.cancelSafely()\n</code></pre> <p>The difference between <code>cancel</code> and <code>cancelSafely</code> is that <code>cancelSafely()</code> will delete the downloaded temporary file.</p>"},{"location":"getting_started/#canceling-all-download-tasks","title":"Canceling all download tasks","text":"<pre><code>downloader.cancelAll()\n</code></pre> <p>or</p> <pre><code>downloader.cancelAllSafely()\n</code></pre> <p><code>cancelAllSafely</code> will delete the downloaded temporary files, including the breakpoint file. The next download will start from scratch.</p>"},{"location":"getting_started/#file-verification","title":"File Verification","text":"<p>Set the <code>MD5</code> value to perform MD5 verification upon download completion</p> <pre><code>val request = Download.Request.Builder()\n// ..\n.md5(md5)\n.build()\n</code></pre> <p>Set the <code>size</code> of the file to verify the file size upon download completion:</p> <pre><code>val request = Download.Request.Builder()\n// ..\n.size(size)\n.build()\n</code></pre>"},{"location":"getting_started/#setting-retries","title":"Setting Retries","text":"<p>Set the number of retries. The default number of retries is 3:</p> <pre><code>val request = Download.Request.Builder()\n// ..\n.retry(5)\n.build()\n</code></pre>"},{"location":"getting_started/#setting-priority","title":"Setting Priority","text":"<p>Supports three priority levels: High, Middle, and Low. The default priority is Middle</p> <pre><code>val request = Download.Request.Builder()\n// ..\n.priority(Download.Priority.HIGH)\n.build()\n</code></pre>"},{"location":"getting_started/#setting-tags","title":"Setting Tags","text":"<p>Tags are used to label tasks and can be used to differentiate different tasks within the app for reporting purposes:</p> <pre><code>val request = Download.Request.Builder()\n// ..\n.tag(tag)\n.build()\n</code></pre>"},{"location":"getting_started/#task-subscription","title":"Task Subscription","text":"<p>In addition to task callbacks, task subscription is supported:</p> <pre><code>val subscriber = object : Download.Subscriber {\noverride fun onSuccess(call: Download.Call, response: Download.Response) {\n// do your job\n}\noverride fun onFailure(call: Download.Call, response: Download.Response) {\n// do your job\n}\n}\ndownloader.subscribe(subscriber)\n</code></pre> <p>Unsubscribe:</p> <pre><code>downloader.unsubscribe(subscriber)\n</code></pre>"},{"location":"in_android/","title":"In Android","text":"<p>In Android, you can add the following dependency</p> <pre><code>implementation(\"com.billbook.lib:okdownloader-android:1.0.0\")\n</code></pre> <p>To add a copy interceptor that records download tasks and prioritizes copying for subsequent downloads of the same resource to <code>prevent duplicate downloads</code>, use the <code>CopyOnExists</code> mechanism:</p> <pre><code>val downloader = Downloader.Builder()\n.addInterceptor(CopyOnExistsInterceptor(context, 1000))\n.build()\n</code></pre> <p>Note: The task records use Google's modern Room database.</p> <p>To add a network interceptor that supports network restrictions</p> <pre><code>val downloader = Downloader.Builder()\n.addInterceptor(NetworkInterceptor(context))\n.build()\n</code></pre> <p>Afterward, you can set network restrictions</p> <pre><code>val request = DownloadRequest.Builder()\n.networkOn(DownloadRequest.NETWORK_WIFI or DownloadRequest.NETWORK_DATA)\n.build()\n</code></pre> <p>To add a storage interceptor that checks for insufficient disk space and avoids ineffective downloads</p> <pre><code>val downloader = Downloader.Builder()\n.addInterceptor(StorageInterceptor(100 * 1024 * 1024)) // 100MB\n.build()\n</code></pre>"},{"location":"optional_settings/","title":"Optional Settings","text":"<p>The following settings are optional and can be customized according to your project needs.</p>"},{"location":"optional_settings/#event-listeners","title":"Event Listeners","text":"<p>Set download event listeners using the <code>eventListenerFactory</code> method. For example:</p> <pre><code>val downloader = Downloader.Builder()\n.eventListenerFactory { ReporterEventListener() }\n.build()\n</code></pre> <p>ReporterEventListener:</p> <pre><code>class ReporterEventListener : EventListener() {\noverride fun callSuccess(call: Download.Call, response: Download.Response) {\n// do your job\n}\noverride fun callFailed(call: Download.Call, response: Download.Response) {\n// do your job\n}\n}\n</code></pre>"},{"location":"optional_settings/#idle-task-callback","title":"Idle Task Callback","text":"<p>Set idle task callback using the <code>idleCallback</code> method</p> <pre><code>val downloader = Downloader.Builder()\n.idleCallback { // handle download pool idle }\n.build()\n</code></pre>"},{"location":"optional_settings/#custom-okhttpclient","title":"Custom OkHttpClient","text":"<p>Set a custom OkHttpClient using the <code>okHttpClientFactory</code> method</p> <pre><code>val downloader = Downloader.Builder()\n.okHttpClientFactory { buildOkHttpClient() }\n.build()\nprivate fun buildOkHttpClient(): OkHttpClient {\nreturn OkHttpClient.Builder()\n.connectTimeout(15, TimeUnit.SECONDS)\n.readTimeout(15, TimeUnit.SECONDS)\n.writeTimeout(15, TimeUnit.SECONDS)\n.retryOnConnectionFailure(true)\n.cache(null)\n.build()\n}\n</code></pre>"},{"location":"optional_settings/#set-default-retry-count","title":"Set Default Retry Count","text":"<p>Set the default retry count. The default is 3</p> <pre><code>val downloader = Downloader.Builder()\n.defaultMaxRetry(10)\n.build()\n</code></pre>"},{"location":"optional_settings/#set-task-execution-thread-pool","title":"Set Task Execution Thread Pool","text":"<p>Set a custom asynchronous download task execution thread pool using the <code>executorService</code> method</p> <pre><code>val downloader = Downloader.Builder()\n.executorService(CustomExecutorService())\n.build()\n</code></pre>"}]}